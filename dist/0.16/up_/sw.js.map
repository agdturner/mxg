{"mappings":"AAAA,sBAAsB;AACtB,+DAA+D;AAC/D,kGAAkG;AAClG,qCAAqC;AAErC,wBAAwB;AACxB,MAAM,aAAa,CAAC,QAAQ,CAAC;AAE7B,uDAAuD;AACvD,MAAM,uBAAuB;IACzB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACH;AAED,yCAAyC;AACzC,KAAK,gBAAgB,CAAC,WAAW,CAAC;IAC9B,MAAM,SAAS,CACX,AAAC,CAAA;QACG,MAAM,QAAQ,MAAM,OAAO,IAAI,CAAC;QAChC,MAAM,MAAM,CAAC;IACjB,CAAA;AAER;AAEA,gCAAgC;AAChC,KAAK,gBAAgB,CAAC,YAAY,CAAC;IAC/B,MAAM,SAAS,CACX,AAAC,CAAA;QACG,MAAM,QAAQ,MAAM,OAAO,IAAI;QAC/B,MAAM,QAAQ,GAAG,CACb,MAAM,GAAG,CAAC,CAAC;YACP,IAAI,SAAS,YACT,OAAO,OAAO,MAAM,CAAC;QAE7B;QAEJ,MAAM,QAAQ,KAAK;IACvB,CAAA;AAER;AAEA,sCAAsC;AACtC,gEAAgE;AAChE,KAAK,gBAAgB,CAAC,SAAS,CAAC;IAC5B,qEAAqE;IACrE,IAAI,MAAM,OAAO,CAAC,IAAI,KAAK,YAAY;QACnC,MAAM,WAAW,CAAC,OAAO,KAAK,CAAC;QAC/B;IACJ;IAEA,uEAAuE;IACvE,MAAM,WAAW,CACb,AAAC,CAAA;QACG,MAAM,QAAQ,MAAM,OAAO,IAAI,CAAC;QAChC,MAAM,iBAAiB,MAAM,MAAM,KAAK,CAAC,MAAM,OAAO,CAAC,GAAG;QAC1D,IAAI,gBACA,gDAAgD;QAChD,OAAO;QAEX,gDAAgD;QAChD,OAAO,IAAI,SAAS,MAAM;YAAE,QAAQ;QAAI;IAC5C,CAAA;AAER,IAEA;;;;;;;;;;;;;;;AAeA","sources":["sw.js"],"sourcesContent":["// The service worker:\n// - caches the static resources that the app needs to function\n// - intercepts server requests and responds with cached responses instead of going to the network\n// - deletes old caches on activation\n\n// The name of the cache\nconst CACHE_NAME = `mxg-0.16`;\n\n// The static resources that the app needs to function.\nconst APP_STATIC_RESOURCES = [\n    \"./\",\n    \"favicon.ico\",\n    \"src/icons/circle.ico\",\n    \"src/icons/circle.svg\",\n    \"src/icons/tire.svg\",\n    \"src/icons/wheel.svg\",\n    \"src/index.html\",\n    \"src/css/style.css\",\n    \"src/ts/app.js\",\n    \"src/images/UoL_Logo.png\",\n];\n\n// On install, cache the static resources\nself.addEventListener(\"install\", (event) => {\n    event.waitUntil(\n        (async () => {\n            const cache = await caches.open(CACHE_NAME);\n            cache.addAll(APP_STATIC_RESOURCES);\n        })(),\n    );\n});\n\n// delete old caches on activate\nself.addEventListener(\"activate\", (event) => {\n    event.waitUntil(\n        (async () => {\n            const names = await caches.keys();\n            await Promise.all(\n                names.map((name) => {\n                    if (name !== CACHE_NAME) {\n                        return caches.delete(name);\n                    }\n                }),\n            );\n            await clients.claim();\n        })(),\n    );\n});\n\n// On fetch, intercept server requests\n// and respond with cached responses instead of going to network\nself.addEventListener(\"fetch\", (event) => {\n    // As a single page app, direct app to always go to cached home page.\n    if (event.request.mode === \"navigate\") {\n        event.respondWith(caches.match(\"/\"));\n        return;\n    }\n\n    // For all other requests, go to the cache first, and then the network.\n    event.respondWith(\n        (async () => {\n            const cache = await caches.open(CACHE_NAME);\n            const cachedResponse = await cache.match(event.request.url);\n            if (cachedResponse) {\n                // Return the cached response if it's available.\n                return cachedResponse;\n            }\n            // If resource isn't in the cache, return a 404.\n            return new Response(null, { status: 404 });\n        })(),\n    );\n});\n\n/**\nif (\"serviceWorker\" in navigator) {\n    //navigator.serviceWorker.register(new URL('/sw.js', import.meta.url))\n    navigator.serviceWorker.register(\"/sw.js\")\n        .then(\n            (registration) => {\n                console.log(\"Service worker registration successful:\", registration);\n            },\n            (error) => {\n                console.error(`Service worker registration failed: ${error}`);\n            },\n        );\n} else {\n    console.error(\"Service workers are not supported.\");\n}\n*/"],"names":[],"version":3,"file":"sw.js.map","sourceRoot":"/__parcel_source_root/"}